[toc]
# 练习0:填写已有实验
...

# 练习1:加载应用程序并执行
- **设计实现过程**  
加载应用程序通过load_icode函数完成,这个过程中要完成的工作有:
```
1.创建新的mm_struct
2.分配新的PDT(且拷贝了内核PDT,从而能正确映射内核虚拟空间)
3.读取可执行程序到用户进程空间
4.调用mm_map()设置用户堆栈段虚拟空间
5.设置current的mm_struct、cr3为新建的,刷新cr3寄存器使用新建的PDT
6.用户线程main函数的参数入栈(复制到用户栈空间,而不是通过push指令)
7.给current设置trapframe,使得中断返回时进入用户线程环境
```

- **当创建一个用户态进程并加载了应用程序后,CPU是如何让这个应用程序最终在用户态执行起来的??**  
这个过程比较复杂,详见lab8中review_all_Q&A.md中关于"创建非idle内核线程"、"创建内核线程"...

# 练习2:父进程复制自己的内存空间给子进程
注意:只有新旧线程属于不同进程时,才需要调用dup_mm => copy_range ...
- **设计实现过程**  
父进程复制内存空间给子进程是通过copy_range(do_fork => copy_mm => dup_mm => copy_range)函数实现,它要完成的任务包括(具体参考copy_range函数):
```
要复制的用户空间的虚拟地址为(start,end):
1.通过页表找到父进程用户空间对应的物理页;
2.将父进程用户空间对应物理页转换成内核虚拟地址;

3.给新进程分配物理页;
4.将新进程物理页转换成内核虚拟地址;

5.使用memcpy将2中内核虚拟地址的内容拷贝到4中内核虚拟地址的内容;
6.在新进程的页表中完成(start...)到新分配的物理地址的映射...

【注】拷贝时为何使用了内核虚拟地址?
因为boot_map_segment中,内核虚拟地址映射了所有物理页!这样做也是为了方便管理...详见详见lab8中review_all_Q&A.md
```
- **如何设计实现Copy on Write 机制?**  
可参考csapp对COW的讲解...  
在vmm.c中将dup_mmap函数中将share变量设置为1,启用共享.在pmm.c中在copy_range函数中添加对共享的处理,如果share为1,那么将子进程的页面映射到父进程的页面.两个进程共享一个页面之后,此时无论任何一个进程修改页面,都会影响另外一个页面,因此`子进程和父进程对于这个共享页面都设置为只读`.当进程尝试修改只读的内存页面的时候,将触发Page Fault异常,在错误代码中P=1、W/R=1,由此可依据错误代码最低两位都为1的断定进程访问了共享的页面,则内核重新分配页面,拷贝页面内容并建立映射关系,这一点在do_pgfault中实现 => 参考自:[实现Copy on Write机制](https://github.com/ZebornDuan/UCore/tree/master/lab5#%E7%BB%83%E4%B9%A01-%E5%8A%A0%E8%BD%BD%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%B9%B6%E6%89%A7%E8%A1%8C)


# 练习3：理解进程执行 fork/exec/wait/exit 的实现
- **系统调用的实现**  
详见详见lab8中review_all_Q&A.md有相应分析

- **对 fork/exec/wait/exit函数的步骤分析**  
详见详见lab8中review_all_Q&A.md有相应分析

- **请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的?**  
详见详见lab8中review_all_Q&A.md有相应分析

- **请给出ucore中一个用户态进程的执行状态生命周期图(包执行状态,执行状态之间的变换关系,以及产生变换的事件或函数调用)**  
详见详见lab8中review_all_Q&A.md有相应分析


# 补充:用户进程的特征
- **从内核线程到用户进程**  
内核线程的管理实现相对是简单的,其特点是直接使用操作系统(比如ucore)在初始化中建立的内核虚拟内存地址空间,不同的内核线程之间可以通过调度器实现线程间的切换,达到分时使用CPU的目的.由于`内核虚拟内存空间是一一映射计算机系统的物理空间的,这使得可用空间的大小不会超过物理空间大小`,所以操作系统程序员编写内核线程时,需要考虑到有限的地址空间,需要保证各个内核线程在执行过程中不会破坏操作系统的正常运行.这样`在实现内核线程管理时,不必考虑涉及与进程相关的虚拟内存管理中的缺页处理、按需分页、写时复制、页换入换出等功能`.如果在内核线程执行过程中出现了访存错误异常或内存不够的情况,就认为操作系统出现错误了,操作系统将直接宕机.在ucore中,就是调用panic函数,进入内核调试监控器kernel_debug_monitor.  

操作系统程序员需要给应用程序员编写的程序提供一个既"宽松"又"严格"的执行环境,让对内存大小和CPU使用时间等资源的限制没有仔细考虑的应用程序都能在操作系统中正常运行,且即使程序不可靠,也只能破坏自己,而不能破坏其他运行程序和整个系统.  
`严格`就是安全性保证,即应用程序执行不会破坏在内存中存在的其他应用程序和操作系统的内存空间等独占的资源;  
`宽松`就算是方便性支持,即提供给应用程序尽量丰富的服务功能和一个远大于物理内存空间的虚拟地址空间,使得应用程序在执行过程中不必考虑很多繁琐的细节(比如如何初始化PCI总线和外设等、如何管理物理内存等).  

- **让用户进程正常运行的用户环境**  
从操作系统的设计和实现的角度看,其实用户进程是指一个应用程序在操作系统提供的一个用户环境中的一次执行过程.操作系统提供的这个用户环境有两方面的特点:  
一方面与`存储空间相关`,即限制用户进程可以访问的物理地址空间,且`让各个用户进程之间的物理内存空间访问不重叠`,这样可以保证不同用户进程之间不能相互破坏各自的内存空间,利用虚拟内存的功能(页换入换出)给用户进程提供了远大于实际物理内存空间的虚拟内存空间;  
另一方面与`执行指令相关`,即限制用户进程可执行的指令,不能让用户进程执行特权指令(比如修改页表起始地址),从而保证用户进程无法破坏系统.但如果不能执行特权指令,则很多功能(比如访问磁盘等)无法实现,所以需要提供某种机制,让操作系统完成需要特权指令才能做的各种服务功能,给用户进程一个"服务窗口",用户进程可以通过这个"窗口"向操作系统提出服务请求,由操作系统来帮助用户进程完成需要特权指令才能做的各种服务.另外,还要有一个"中断窗口",让用户进程不主动放弃使用CPU时,操作系统能够通过这个"中断窗口"强制让用户进程放弃使用CPU,从而让其他用户进程有机会执行.  

可以把这个用户环境定义为如下组成部分:  
1.建立用户虚拟空间的页表和支持页换入换出机制的用户内存访存错误异常服务例程:提供地址隔离和超过物理空间大小的虚存空间;  
2.应用程序执行的用户态CPU特权级:在用户态CPU特权级,应用程序只能执行一般指令,如果特权指令,结果不是无效就是产生"执行非法指令"异常;  
3.系统调用机制:给用户进程提供"服务窗口"(系统调用其实也是通过中断/异常实现);  
4.中断响应机制:给用户进程设置"中断窗口",这样产生中断后,当前执行的用户进程将被强制打断,CPU控制权将被操作系统的中断服务例程使用;  


- **用户进程的执行过程分析(非常重要!)**  
如果用户进程由于某种原因下进入内核态后,那在内核态执行的是什么呢?还是用户进程吗?  
=> 当产生外设中断、CPU执行异常(比如访存错误)、陷入(系统调用)、用户进程就会切换到内核中的操作系统中来.表面上看,到内核态后,操作系统取得了CPU控制权,所以现在执行的应该是操作系统代码,由于此时CPU处于核心态特权级,所以操作系统的执行过程就应该是内核进程了.这样理解忽略了操作系统的具体实现,如果考虑操作系统的具体实现,应该如何来理解进程呢?(下述只是两种稍微不同的观点,不存在对错区别)  

1.从进程控制块的角度看,`如果执行了进程执行现场(上下文)的切换,就认为到另外一个进程执行了`,即进程的分界点设定在执行进程切换的前后.到底切换了什么呢?其实`只是切换了进程的页表和相关硬件寄存器`,这些信息都保存在进程控制块中的相关域中.所以,我们可以把执行应用程序的代码一直到执行操作系统中的进程切换处为止都认为是一个应用程序的执行过程即进程。因为在这个过程中,没有更换到另外一个进程控制块的进程的页表和相关硬件寄存器.  

2.从指令执行的角度看,操作系统的主要功能是给上层应用提供服务,管理整个计算机系统中的资源.操作系统需要响应的事件包括三类:`外设中断、CPU执行异常(比如访存错误)、陷入(系统调用)`.如果用户进程通过`系统调用`要求操作系统提供服务,那么用户进程的角度看,操作系统就是一个特殊的软件库(比如相对于用户态的libc库,操作系统可看作是内核态的libc库),完成用户进程的需求.从执行逻辑上看,是用户进程"主观"执行的一部分,即用户进程"知道"操作系统要做的事情.那么在这种情况下,进程的代码空间包括用户态的执行程序和内核态响应用户进程通过系统调用而在核心特权态执行服务请求的操作系统代码,为此这种情况下的进程的内存虚拟空间也包括两部分:用户态的虚地址空间和核心态的虚地址空间;  但如果此时发生的事件是`外设中断和CPU执行异常`,虽然CPU控制权也转入到操作系统中的中断服务例程,但这些内核执行代码执行过程是用户进程"不知道"的,是另外一段执行逻辑.那么在这种情况下,实际上是执行了两段目标不同的执行程序,一个是代表应用程序的用户进程,一个是代表中断服务例程处理外设中断和CPU执行异常的内核线程.这个用户进程和内核线程在产生中断或异常的时候,CPU硬件就完成了它们之间的指令流切换.  


- **用户进程的运行状态分析**  
一个用户进程一般的运行状态有五种:创建(new)态、就绪(ready)态、运行(running)态、等待(blocked)态、退出(exit)态.各个状态之间会由于发生了某事件而进行状态转换.  
`创建`:操作系统完成进程的创建工作,而体现进程存在的就是进程控制块,所以一旦操作系统创建了进程控制块,则可以认为此时进程就已经存在了,但由于进程能够运行的各种资源还没准备好,所以此时的进程处于创建(new)态.  
`就绪`:创建了进程控制块后,进程并不能就执行了,还需准备好各种资源,如果把进程执行所需要的虚拟内存空间,执行代码,要处理的数据等都准备好了,则此时进程已经可以执行了,但还没有被操作系统调度,需要等待操作系统选择这个进程执行,于是把这个做好"执行准备"的进程放入到一个队列中,并可以认为此时进程处于就绪(ready)态.  
`运行`:当操作系统的调度器从就绪进程队列中选择了一个就绪进程后,通过执行进程切换,就让这个被选上的就绪进程执行了,此时进程就处于运行(running)态了.到了运行态后,会出现三种事件(如下=> 状态分别转换到阻塞/退出/就绪).  
`等待/阻塞`:如果进程需要等待某个事件(比如主动睡眠10秒钟;或进程访问某个内存空间,但此内存空间被换出到硬盘swap分区中了,进程不得不等待操作系统把缓慢的硬盘上的数据重新读回到内存中),那么操作系统会把CPU给其他进程执行,并把进程状态从运行(running)态转换为等待(blocked)态.  
`退出`:如果用户进程的应用程序逻辑流程执行结束了,那么操作系统会把CPU给其他进程执行,并把进程状态从运行(running)态转换为退出(exit)态,并准备回收用户进程占用的各种资源,当把表示整个进程存在的进程控制块也回收了,这进程就不存在了.在这整个回收过程中,进程都处于退出(exit)态.  
考虑到在内存中存在多个处于就绪态的用户进程,但只有一个CPU,所以为了公平起见,每个就绪态进程都只有有限的时间片段,当一个运行态的进程用完了它的时间片段后,操作系统会剥夺此进程的CPU使用权,并把此进程状态从运行(running)态转换为就绪(ready)态,最后把CPU给其他进程执行.如果某个处于等待(blocked)态的进程所等待的事件产生了(比如睡眠时间到,或需要访问的数据已经从硬盘换入到内存中),则操作系统会通过把等待此事件的进程状态从等待(blocked)态转到就绪(ready)态.这样进程的整个状态转换形成了一个有限状态自动机.  
除上面外,如果`进程被换出到外存,则处于挂起状态`......  


# 补充:用户进程管理
## 实验执行流程概述
由于进程的执行空间扩展到了用户态空间,且出现了创建子进程执行应用程序等与lab4有较大不同的地方,所以具体实现的不同主要集中在`进程管理和内存管理`部分.初始化的总控函数kern_init没有任何变化,但这并不意味着lab4与lab5差别不大.其实kern_init调用的物理内存初始化,进程管理初始化等都有一定的变化.  

在`内存管理`部分,与lab4最大的区别就是增加用户态虚拟内存的管理.`为了管理用户态的虚拟内存,需要对页表的内容进行扩展,能够把部分物理内存映射为用户态虚拟内存`.如果某进程执行过程中,CPU在用户态下执行(在CS段寄存器最低两位包含有一个2位的优先级域,如果为0,表示CPU运行在特权态;如果为3,表示CPU运行在用户态),则可以访问本进程页表描述的用户态虚拟内存,但由于权限不够,不能访问内核态虚拟内存.另一方面,不同的进程有各自的页表,所以即使不同进程的用户态虚拟地址相同,`但由于页表把虚拟页映射到了不同的物理页帧,所以不同进程的虚拟内存空间是被隔离开的`,相互之间无法直接访问.`在用户态内存空间和内核态内存空间之间需要拷贝数据,让CPU处在内核态才能完成对用户空间的读或写,为此需要设计专门的拷贝函数(copy_from_user和copy_to_user)完成`.但反之则会导致违反CPU的权限管理,导致内存访问异常.  

在`进程管理`方面,主要涉及到的是进程控制块中与内存管理相关的部分,包括建立进程的页表和维护进程可访问空间(可能还没有建立虚实映射关系)的信息、加载一个ELF格式的程序到进程控制块管理的内存中的方法、在进程复制(fork)过程中、把父进程的内存空间拷贝到子进程内存空间的技术;&nbsp;&nbsp;另外一部分与用户态进程生命周期管理相关,包括让进程放弃CPU而睡眠等待某事件、让父进程等待子进程结束、一个进程杀死另一个进程、给进程发消息、建立进程的血缘关系链表.  

当实现了上述内存管理和进程管理的需求后,接下来ucore的用户进程管理工作就比较简单了.`首先,"硬"构造出第一个进程(lab4中已有描述),它是后续所有进程的祖先`; &nbsp;然后,在proc_init函数中,通过alloc把当前ucore的执行环境转变成idle内核线程的执行现场; &nbsp;然再后调用kernl_thread来创建第二个内核线程init_main(initproc),而init_main内核线程又创建了user_main内核线程.到此,`内核线程创建完毕,应该开始用户进程的创建过程,这第一步实际上是通过user_main函数调用kernel_tread创建子进程,通过kernel_execve调用来把某一具体程序的执行内容放入内存`.具体的放置方式是根据ld在此文件上的地址分配为基本原则,把程序的不同部分放到某进程的用户空间中,从而通过此进程来完成程序描述的任务.一旦执行了这一程序对应的进程,就会从内核态切换到用户态继续执行.以此类推,CPU在用户空间执行的用户进程,其地址空间不会被其他用户的进程影响,但由于系统调用(用户进程直接获得操作系统服务的唯一通道)、外设中断和异常中断的会随时产生,从而间接推动了用户进程实现用户态到到内核态的切换工作.ucore对CPU内核态与用户态的切换过程需要比较仔细地分析(这其实是实验一的扩展练习).当进程执行结束后,需回收进程占用和没消耗完毕的设备整个过程,且为新的创建进程请求提供服务.在本实验中,当系统中存在多个进程或内核线程时,ucore采用了一种FIFO的很简单的调度方法来管理每个进程占用CPU的时间和频度等.在ucore运行过程中,由于调度、时间中断、系统调用等原因,使得进程会进行切换、创建、睡眠、等待、发消息等各种不同的操作,周而复始、生生不息.

## 创建用户进程(重要)
- **1.应用程序的组成和编译**  
以user/hello.c下的用户程序为例:  
```
int main(void) {
    cprintf("Hello world!!.\n");
    cprintf("I am process %d.\n", getpid());   //getpid()内部,调用系统调用sys_getpid
    cprintf("hello pass.\n");
    return 0;
}
```

通过MakeFile编译项目,查看编译过程中的打印信息可知,hello.c还依赖许多用户态库函数,如下:  
user/libs/initcode.S:`所有应用程序的起始用户态执行地址`"_start",调整了EBP和ESP后,调用umain函数;  
user/libs/umain.c:实现了umain函数,这是所有应用程序执行的第一个C函数,`它将调用应用程序的main函数,并在main函数结束后调用exit函数`,而exit函数最终将调用sys_exit系统调用,让操作系统回收进程资源;  
user/libs/ulib.*:实现了最小的C函数库,除了一些与系统调用无关的函数,其他函数是对访问系统调用的包装;  
user/libs/syscall.*:用户层发出系统调用的具体实现;  
user/libs/stdio.c:实现cprintf函数,通过系统调用sys_putc来完成字符输出;  
user/libs/panic.c:实现__panic/__warn函数,通过系统调用sys_exit完成用户进程退出;  

除了这些用户态库函数实现外,还`有一些libs/*.*是操作系统内核和应用程序共用的函数实现`.这些用户库函数其实在本质上与UNIX系统中的标准libc没有区别,只是实现得很简单,但hello应用程序的正确执行离不开这些库函数.
```
【注意】libs/*.[ch]、user/libs/*.[ch]、user/*.[ch]的源码中没有任何特权指令.

在make的最后一步执行了一个ld命令,把hello应用程序的执行码obj/__user_hello.out连接在了ucore kernel的末尾.且ld命令会在kernel中会把__user_hello.out的位置和大小记录在全局变量_binary_obj___user_hello_out_start和_binary_obj___user_hello_out_size中,这样这个hello用户程序就能够和ucore内核一起被 bootloader 加载到内存里,并且通过这两个全局变量定位hello用户程序执行码的起始位置和大小.而到了与文件系统相关的实验后,ucore会提供一个简单的文件系统,那时所有的用户程序就都不再用这种方法进行加载了,而可以用大家熟悉的文件方式进行加载了.
```

- **2.用户进程的虚拟地址空间**  
tools/user.ld描述了用户程序的用户虚拟空间的执行入口虚拟地址:  
```
SECTIONS {
    /* Load programs at this address: "." means the current address */
    . = 0x800020;

    .text : {
        *(.text .stub .text.* .gnu.linkonce.t.*)
    }
    ......
```
tools/kernel.ld描述了操作系统的内核虚拟空间的起始入口虚拟地址:  
```
SECTIONS {
    /* Load the kernel at this address: "." means the current address */
    . = 0xC0100000;

    .text : {
        *(.text .stub .text.* .gnu.linkonce.t.*)
    }
```
这样ucore把`用户进程的虚拟地址空间分了两块,一块与内核线程一样,是所有用户进程都共享的内核虚拟地址空间,映射到同样的物理内存空间中,这样在物理内存中只需放置一份内核代码,使得用户进程从用户态进入核心态时,内核代码可以统一应对不同的内核程序;另外一块是用户虚拟地址空间,虽然虚拟地址范围一样,但映射到不同且没有交集的物理内存空间中`.这样当ucore把用户进程的执行代码(即应用程序的执行代码)和数据(即应用程序的全局变量等)放到用户虚拟地址空间中时,确保了各个进程不会"非法"访问到其他进程的物理内存空间. => 用户进程对应的虚拟地址空间如下:  
```
/* *
 * Virtual memory map:                                          Permissions
 *                                                              kernel/user
 *
 *     4G ------------------> +---------------------------------+
 *                            |                                 |
 *                            |         Empty Memory (*)        |
 *                            |                                 |
 *                            +---------------------------------+ 0xFB000000
 *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE
 *     VPT -----------------> +---------------------------------+ 0xFAC00000
 *                            |        Invalid Memory (*)       | --/--
 *     KERNTOP -------------> +---------------------------------+ 0xF8000000
 *                            |                                 |
 *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE
 *                            |                                 |
 *     KERNBASE ------------> +---------------------------------+ 0xC0000000
 *                            |        Invalid Memory (*)       | --/--
 *     USERTOP -------------> +---------------------------------+ 0xB0000000
 *                            |           User stack            |
 *                            +---------------------------------+
 *                            |                                 |
 *                            :                                 :
 *                            |         ~~~~~~~~~~~~~~~~        |
 *                            :                                 :
 *                            |                                 |
 *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                            |       User Program & Heap       |
 *     UTEXT ---------------> +---------------------------------+ 0x00800000
 *                            |        Invalid Memory (*)       | --/--
 *                            |  - - - - - - - - - - - - - - -  |
 *                            |    User STAB Data (optional)    |
 *     USERBASE, USTAB------> +---------------------------------+ 0x00200000
 *                            |        Invalid Memory (*)       | --/--
 *     0 -------------------> +---------------------------------+ 0x00000000
 * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
 *     "Empty Memory" is normally unmapped, but user programs may map pages
 *     there if desired.
 *
 * */
```

- **3.创建并执行用户进程**  
本实验中`第一个用户进程是由第二个内核线程initproc通过把hello应用程序执行码覆盖到initproc的用户虚拟内存空间来创建`的(详见proc.c):
```
// kernel_execve - do SYS_exec syscall to exec a user program called by user_main kernel_thread
static int
kernel_execve(const char *name, unsigned char *binary, size_t size) {
    int ret, len = strlen(name);
    asm volatile (
        "int %1;"
        : "=a" (ret)
        : "i" (T_SYSCALL), "0" (SYS_exec), "d" (name), "c" (len), "b" (binary), "D" (size)
        : "memory");
    return ret;
}

#define __KERNEL_EXECVE(name, binary, size) ({                          \
            cprintf("kernel_execve: pid = %d, name = \"%s\".\n",        \
                    current->pid, name);                                \
            kernel_execve(name, binary, (size_t)(size));                \
        })

#define KERNEL_EXECVE(x) ({                                             \
            extern unsigned char _binary_obj___user_##x##_out_start[],  \
                _binary_obj___user_##x##_out_size[];                    \
            __KERNEL_EXECVE(#x, _binary_obj___user_##x##_out_start,     \
                            _binary_obj___user_##x##_out_size);         \
        })
........

// user_main - kernel thread used to exec a user program
static int user_main(void *arg) {
#ifdef TEST
    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);  // 最终调用kernel_execve函数
#else
    KERNEL_EXECVE(exit);
#endif
    panic("user_main execve failed.\n");
}
```
initproc的执行主体是user_main函数; =>user_main默认执行KERNEL_EXECVE(hello).(注:实习指导书与项目代码不一致,最终以代码为准);  =>上述宏最终调用的是kernel_execve()函数; =>kernel_execve然后进行系统调用SYS_exec; ....=>系统调用不断查找下去,发现最终是调用do_execve函数(见proc.c)来完成用户进程的创建工作.  
`do_execve()函数的工作流程`  
&nbsp;&nbsp;1.为加载新的执行码做好用户态内存空间清空准备.如果mm不为NULL,则设置页表为内核空间页表,且进一步判断mm的引用计数减1后是否为0,如果为0,则表明没有进程再需要此进程所占用的内存空间,为此将根据mm中的记录,释放进程所占用户空间内存和进程页表本身所占空间.最后把当前进程的mm内存管理指针为空.由于此处的initproc是内核线程,所以mm为NULL,整个处理都不会做;  
&nbsp;&nbsp;2.接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中.这里涉及到读ELF格式的文件,申请内存空间,建立用户态虚存空间,加载应用程序执行码等 => 这个部分由load_icode函数完成(见下文).  
`load_icode()函数工作流程`  
&nbsp;&nbsp;1.调用mm_create函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化;  
&nbsp;&nbsp;2.调用setup_pgdir来申请一个页目录表所需的一个页大小的内存空间,并把描述ucore内核虚空间映射的内核页表(boot_pgdir)所指的内容拷贝到此新目录表中,最后让mm->pgdir指向此页目录表,这就是进程新的页目录表了,且`能够正确映射内核虚空间`;  
&nbsp;&nbsp;3.根据应用程序执行码的起始位置来解析此ELF格式的执行程序,并调用mm_map函数根据ELF格式的执行程序说明的各个段(代码段、数据段、BSS段等)的起始位置和大小建立对应的vma结构,并把vma插入到mm结构中,从而表明了用户进程的合法用户态虚拟地址空间;  
&nbsp;&nbsp;4.调用根据执行程序各个段的大小分配物理内存空间,并根据执行程序各个段的起始位置确定虚拟地址,并在页表中建立好物理地址和虚拟地址的映射关系,然后把执行程序`各个段的内容拷贝到相应的内核虚拟地址中`(为什么是拷贝到内核虚拟地址??),至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了;  
&nbsp;&nbsp;5.需要给用户进程设置用户栈,为此调用mm_mmap函数建立用户栈的vma结构,明确用户栈的位置在用户虚空间的顶端,大小为256个页,即1MB,并分配一定数量的物理内存且建立好栈的虚地址<-->物理地址映射关系;  
&nbsp;&nbsp;6.至此,进程内的内存管理vma和mm数据结构已经建立完成,于是把mm->pgdir赋值到cr3寄存器中,即更新了用户进程的虚拟内存空间,`此时的initproc已经被hello的代码和数据覆盖,成为了第一个用户进程,但此时这个用户进程的执行现场还没建立好`;  
&nbsp;&nbsp;7.先清空进程的中断帧,再重新设置进程的中断帧,使得在执行中断返回指令"iret"后,能够让CPU转到用户态特权级,并回到用户态内存空间,使用用户态的代码段、数据段和堆栈,且能够跳转到用户进程的第一条指令执行,并确保在用户态能够响应中断;

至此,用户进程的用户环境已经搭建完毕.此时initproc将按产生系统调用的函数调用路径原路返回,执行中断返回指令"iret"(位于trapentry.S的最后一句)后,将切换到用户进程hello的第一条语句位置_start处(位于user/libs/initcode.S的第三句)开始执行.


## 进程退出(exit)和等待进程(wait)
- **进程退出**  
ucore分了两步来完成这个工作:首先由进程本身完成大部分资源的占用内存回收工作,然后由此进程的父进程完成剩余资源占用内存的回收工作.`为何不让进程本身完成所有的资源回收工作呢?这是因为进程要执行回收操作,就表明此进程还存在,还在执行指令,这就需要内核栈的空间不能释放,且表示进程存在的进程控制块不能释放.所以需要父进程来帮忙释放子进程无法完成的这两个资源回收工作`.为此在用户态的函数库中提供了exit函数,此函数最终访问sys_exit系统调用接口让操作系统来帮助当前进程执行退出过程中的部分资源回收.  
首先,exit函数会把一个退出码error_code传递给ucore,ucore通过执行内核函数do_exit来完成对当前进程的退出处理,主要工作简单地说就是回收当前进程所占的大部分内存资源,并`通知父进程完成最后的回收工作`,具体流程如下:  
**1**.如果current->mm != NULL,表示是用户进程,则开始回收此用户进程所占用的用户态虚拟内存空间:  
a)首先执行"lcr3(boot_cr3)",切换到内核态的页表上,这样当前用户进程目前只能在内核虚拟地址空间执行了,这是为了确保后续释放用户态内存和进程页表的工作能够正常执行;  
b)如果当前进程控制块的成员变量mm的成员变量mm_count减1后为0(表明这个mm没有再被其他进程共享,可以彻底释放进程所占的用户虚拟空间了),则开始回收用户进程所占的内存资源:  
i.调用exit_mmap函数释放current->mm->vma链表中每个vma描述的进程合法空间中实际分配的内存,然后把对应的页表项内容清空,最后还把页表所占用的空间释放并把对应的页目录表项清空;  
ii.调用put_pgdir函数释放当前进程的页目录所占的内存;  
iii.调用mm_destroy函数释放mm中的vma所占内存,最后释放mm所占内存;  
c)此时设置current->mm为NULL,表示与当前进程相关的用户虚拟内存空间和对应的内存管理成员变量所占的内核虚拟内存空间已经回收完毕;  
**2**.这时,设置当前进程的执行状态current->state=PROC_ZOMBIE,当前进程的退出码current->exit_code=error_code.此时当前进程已经不能被调度了,需要此进程的父进程来做最后的回收工作(即`回收描述此进程的内核栈和进程控制块`);  
**3**.如果当前进程的父进程current->parent处于等待子进程状态：current->parent->wait_state==WT_CHILD,则唤醒父进程(即执行"wakup_proc(current->parent)"),让父进程帮助自己完成最后的资源回收;  
**4**.`如果当前进程还有子进程,则需要把这些子进程的父进程指针设置为内核线程initproc`,且各个子进程指针需要插入到initproc的子进程链表中.如果某个子进程的执行状态是PROC_ZOMBIE,则需要唤醒initproc来完成对此子进程的最后回收工作;  
**5**.执行schedule()函数,选择新的进程执行.  

- **等待子进程**  
父进程如何完成对子进程的最后回收工作呢?这要求父进程要执行wait用户函数或wait_pid用户函数,这两个函数的区别是:wait函数等待任意子进程的结束通知,而wait_pid函数等待进程id号为pid的子进程结束通知.`这两个函数最终访问sys_wait系统调用接口让ucore来完成对子进程的最后回收工作`,即回收子进程的内核栈和进程控制块所占内存空间,具体流程如下:  
**1**.如果pid!=0,表示只找一个进程id号为pid的退出状态的子进程,否则找任意一个处于退出状态的子进程;  
**2**.如果此子进程的执行状态不为PROC_ZOMBIE,表明此子进程还没有退出,则当前进程只好设置自己的执行状态为PROC_SLEEPING,`睡眠`原因为WT_CHILD(即等待子进程退出),调用schedule()函数选择新的进程执行,自己睡眠等待,如果被唤醒,则重复跳回步骤1处执行(注:这里睡眠其实就是阻塞);  
**3**.如果此子进程的执行状态为PROC_ZOMBIE,表明此子进程处于退出状态,需要当前进程(即子进程的父进程)完成对子进程的最终回收工作,即首先把子进程控制块从两个进程队列proc_list和hash_list中删除,并释放子进程的内核堆栈和进程控制块.自此,子进程才彻底地结束了它的执行过程,消除了它所占用的所有资源.



## 系统调用实现(重要)
- **0.概述**  
为什么需要实现系统调用呢?用户进程只能在操作系统给它圈定好的"用户环境"中执行,但"用户环境"限制了用户进程能够执行的指令,即用户进程只能执行一般的指令,无法执行特权指令.如果用户进程想执行一些需要`特权指令`的任务,比如通过网卡发网络包等,只能让操作系统来代劳了.于是就需要一种机制来确保用户进程不能执行特权指令,但能够请操作系统“"帮忙"完成需要特权指令的任务,这种机制就是系统调用.  
从硬件层面上看,需要硬件能够支持在用户态的用户进程通过某种机制切换到内核态.试验一讲述中断硬件支持和软件处理过程其实就可以用来完成系统调用所需的软硬件支持.下面我们来看看如何在ucore中实现系统调用.  

- **1.初始化系统调用对应的中断描述符**  
在ucore初始化函数kern_init中调用了idt_init函数来初始化中断描述符表,并设置一个特定中断号的中断门,专门用于用户进程访问系统调用(trap.c):
```
void idt_init(void) {
    extern uintptr_t __vectors[];
    int i;
    for (i = 0; i < sizeof(idt)/sizeof(struct gatedesc); i ++) {
        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);
    }
    SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);
    lidt(&idt_pd);
}
```
可以看到在执行加载中断描述符表lidt指令前,专门设置了一个特殊的中断描述符idt[T_SYSCALL],它的特权级设置为DPL_USER,中断向量处理地址在__vectors[T_SYSCALL]处.这样建立好这个中断描述符后,一旦用户进程执行"INT T_SYSCALL"后,由于此中断允许用户态进程产生(注意它的特权级设置为DPL_USER),所以CPU就会从用户态切换到内核态,保存相关寄存器,并跳转到__vectors[T_SYSCALL]处开始执行,形成如下执行路径:
```
vector128(vectors.S) => alltraps(trapentry.S) => >trap(trap.c) => dispatch(trap.c) => syscall(syscall.c)
```
在syscall中,根据系统调用号来完成不同的系统调用服务.  

- **2.建立系统调用的用户库准备**  
在操作系统中初始化好系统调用相关的中断描述符、中断处理起始地址等后,还需在用户态的应用程序中初始化好相关工作,简化应用程序访问系统调用的复杂性.为此在用户态建立了一个中间层,即简化的libc实现,在user/libs/ulib.* 和user/libs/syscall.* 中完成了对访问系统调用的封装.用户态最终的访问系统调用函数是syscall,实现如下:
```
static inline int
syscall(int num, ...) {
    va_list ap;
    va_start(ap, num);
    uint32_t a[MAX_ARGS];
    int i, ret;
    for (i = 0; i < MAX_ARGS; i ++) {
        a[i] = va_arg(ap, uint32_t);
    }
    va_end(ap);

    asm volatile (
        "int %1;"
        : "=a" (ret)
        : "i" (T_SYSCALL),
          "a" (num),
          "d" (a[0]),
          "c" (a[1]),
          "b" (a[2]),
          "D" (a[3]),
          "S" (a[4])
        : "cc", "memory");
    return ret;
}
```
可以看出,应用程序调用的exit/fork/wait/getpid等库函数最终都会调用syscall函数,只是调用的参数不同而已,如果看最终的汇编代码会更清楚:
```
......
  34:    8b 55 d4               mov    -0x2c(%ebp),%edx
  37:    8b 4d d8               mov    -0x28(%ebp),%ecx
  3a:    8b 5d dc                mov    -0x24(%ebp),%ebx
  3d:    8b 7d e0                mov    -0x20(%ebp),%edi
  40:    8b 75 e4                mov    -0x1c(%ebp),%esi
  43:    8b 45 08               mov    0x8(%ebp),%eax
  46:    cd 80                   int    $0x80
48: 89 45 f0                mov    %eax,-0x10(%ebp)
......
```
可以看到其实是`把系统调用号放到EAX,其他5个参数a[0]~a[4]分别保存到EDX/ECX/EBX/EDI/ESI五个寄存器中,即最多用6个寄存器来传递系统调用的参数,且系统调用的返回结果是EAX`.比如对于getpid库函数而言,系统调用号(SYS_getpid=18)是保存在EAX中,返回值(调用此库函数的的当前进程号pid)也在EAX中.  

- **3.与用户进程相关的系统调用**  

|系统调用名|	含义	|具体完成服务的函数|
|---------|------------|----------------|
|SYS_exit|	process exit|	do_exit|
|SYS_fork|	create child process, dup mm|	do_fork-->wakeup_proc|
|SYS_wait|	wait child process|	do_wait|
|SYS_exec|	after fork, process execute a new program|	load a program and refresh the mm|
|SYS_yield|	process flag itself need resecheduling|	proc->need_sched=1, then scheduler will rescheule this process|
|SYS_kill|	kill process|	do_kill-->proc->flags= PF_EXITING, -->wakeup_proc-->do_wait-->do_exit
|SYS_getpid|	get the process's pid|	


- **4.系统调用的执行过程**  
`与用户态函数调用的区别`  
1.不是通过"CALL"指令而是通过"INT"指令发起调用;  
2.不是通过"RET"指令返回,而是通过"IRET"指令完成调用返回;  
3.当到达内核态后,操作系统需要严格检查系统调用传递的参数,确保不破坏整个系统的安全性;  
4.执行系统调用可导致进程等待某事件发生,从而可引起进程切换;  

以系统调用getpid()为例:当用户进程调用getpid函数,最终执行到"INT T_SYSCALL"指令后,CPU根据操作系统建立的系统调用中断描述符,转入内核态,并跳转到vector128处(kern/trap/vectors.S),开始了操作系统的系统调用执行过程,函数调用和返回操作的关系如下所示:  
```
vector128(vectors.S) => __alltraps(trapentry.S) => trap(trap.c) => dispatch(trap.c) =>syscall(syscall.c) => sys_getpid(syscall.c) => ...... => trapret(trapentry.S)
```
`在执行trap函数前,软件还需进一步保存执行系统调用前的执行现场,即把与用户进程继续执行所需的相关寄存器等当前内容保存到当前进程的中断帧trapframe中`(注意,`在创建进程时,把进程的trapframe放在给进程的内核栈分配的空间的顶部`).软件做的工作在vector128和__alltraps的起始部分:
```
vectors.S::vector128起始处:
  pushl $0
  pushl $128
......
trapentry.S::__alltraps起始处:
pushl %ds
  pushl %es
  pushal
......
```
自此,用于保存用户态的用户进程执行现场的trapframe的内容填写完毕,操作系统可开始完成具体的系统调用服务.在sys_getpid函数中,简单地把当前进程的pid成员变量做为函数返回值就是一个具体的系统调用服务.完成服务后,操作系统按调用关系的路径原路返回到__alltraps中.然后操作系统开始根据当前进程的中断帧内容做恢复执行现场操作.其实就是把trapframe的一部分内容保存到寄存器内容.恢复寄存器内容结束后,调整内核堆栈指针到中断帧的tf_eip处,这时内核栈的结构如下:
```
/* below here defined by x86 hardware */
    uintptr_t tf_eip;
    uint16_t tf_cs;
    uint16_t tf_padding3;
    uint32_t tf_eflags;
/* below here only when crossing rings */
    uintptr_t tf_esp;
    uint16_t tf_ss;
    uint16_t tf_padding4;
```
这时执行"IRET"指令后,CPU根据内核栈的情况恢复到用户态,并把EIP指向tf_eip的值,即"INT T_SYSCALL"后的那条指令.这样整个系统调用就执行完毕了.






# 相关要点/问题速览

- **关于用户进程虚拟地址空间的内核部分**  
所有用户进程的虚拟地址空间的内核部分,全部映射到内核,对应同一块物理内存;  
而用户进程的虚拟地址空间的用户部分,映射到各自的程序、对应不同的物理内存!  

- **为何不让进程本身完成所有的资源回收工作呢?**  
这是因为进程要执行回收操作,就表明此进程还存在,还在执行指令,这就需要内核栈的空间不能释放,且表示进程存在的进程控制块不能释放.所以需要父进程来帮忙释放子进程无法完成的这两个资源回收工作

- **内核线程与用户线程在地址空间上的区别?**  
内核线程直接使用操作系统(比如ucore)在初始化中建立的内核虚拟内存地址空间,内核虚拟内存空间是一一映射计算机系统的物理空间的,这使得可用空间的大小不会超过物理空间大小.`在实现内核线程管理时,不必考虑涉及与进程相关的虚拟内存管理中的缺页处理、按需分页、写时复制、页换入换出等功能`  

- **用户线程陷入内核时变成内核线程了吗?发生中断(外设中断、cpu异常,不是系统调用)后属于内核线程吗?**  
详见"用户进程的特征" > "用户进程的执行过程分析"  
建议从进程控制块的角度来区分:用户线程即使陷入内核,仍然是用户线程,只是暂时有较高的权限.

- **用户进程的虚拟地址空间是如何划分的?**  
用户进程的虚拟地址空间分了两块;  
1.`一块与内核线程一样,是所有用户进程都共享的内核虚拟地址空间,映射到同样的物理内存空间中,这样在物理内存中只需放置一份内核代码,使得用户进程从用户态进入核心态时,内核代码可以统一应对不同的内核程序`=> 这部分对所以用户进程都一样;  
2.另外一块是用户虚拟地址空间,虽然虚拟地址范围一样,但映射到不同且没有交集的物理内存空间中;  
完成的用户进程虚拟地址空间布局如下(可在memlayout.h中查看):  
```
/* *
 * Virtual memory map:                                          Permissions
 *                                                              kernel/user
 *
 *     4G ------------------> +---------------------------------+
 *                            |                                 |
 *                            |         Empty Memory (*)        |
 *                            |                                 |
 *                            +---------------------------------+ 0xFB000000
 *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE
 *     VPT -----------------> +---------------------------------+ 0xFAC00000
 *                            |        Invalid Memory (*)       | --/--
 *     KERNTOP -------------> +---------------------------------+ 0xF8000000
 *                            |                                 |
 *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE
 *                            |                                 |
 *     KERNBASE ------------> +---------------------------------+ 0xC0000000
 *                            |        Invalid Memory (*)       | --/--
 *     USERTOP -------------> +---------------------------------+ 0xB0000000
 *                            |           User stack            |
 *                            +---------------------------------+
 *                            |                                 |
 *                            :                                 :
 *                            |         ~~~~~~~~~~~~~~~~        |
 *                            :                                 :
 *                            |                                 |
 *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                            |       User Program & Heap       |
 *     UTEXT ---------------> +---------------------------------+ 0x00800000
 *                            |        Invalid Memory (*)       | --/--
 *                            |  - - - - - - - - - - - - - - -  |
 *                            |    User STAB Data (optional)    |
 *     USERBASE, USTAB------> +---------------------------------+ 0x00200000
 *                            |        Invalid Memory (*)       | --/--
 *     0 -------------------> +---------------------------------+ 0x00000000
 * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
 *     "Empty Memory" is normally unmapped, but user programs may map pages
 *     there if desired.
 *
 * */
```